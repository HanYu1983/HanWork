{"version":3,"sources":["app3/playerImpl.cljs"],"mappings":";;;;AAMA,AAAAA,AAAA,AAAA,AAAkDC,AAAEC,AAAMC;AAA1D,AACE,AAAA,AAAAC,AAAA,AAAAC,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAJ,AAASK;AAAT,AAAAH,AAAA,AAAAC,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAJ,AACSM;AADT,AAAA,AAEQ,AACE,AAAA,AAASL;AAAM,AAACM,AAAMD;;AADxB,AAEE,AAAA,AAAQL;AAAM,AAACM,AAAMF;;AAFvB,AAGO,AAAAG,AAAA;;;;;AAGjB,AAAAC,AAAA,AAAA,AAAuDV,AAAEC,AAAMU,AAAOT;AAAtE,AACE,AAAMU,AAAM,AAAA,AAAQV;AACdW,AAAU,AAAA,AAAYD;AACtBE,AAAU,AAACC,AAAWb,AAAKS;AAC3BK,AAAc,AAAK,AAACC,AAAEJ,AAAUC;AAHtC,AAIE,AAAIE;AACF,AAAME,AAAO,AAACC,AAAeP,AAAME;AAC7BF,AAAM,AAACQ,AAAUR,AAAME,AAAUI;AADvC,AAEE,AAAA,AAAA,AAACG,AAAMnB,AAAaU;;AACtB,AAAMU,AAAW,AAAG,AAAI,AAAAC,AACJ,AAAA,AAAWX;AAD/B,AAEE,AAAI,AAAA,AAAGU;AACL,AAAMJ,AAAO,AAACC,AAAeP,AAAME;AAC7BF,AAAM,AAACQ,AAAUR,AAAME,AAAUI;AADvC,AAEE,AAAA,AAAA,AAACG,AAAMnB,AAAaU;;AACtBV;;;;AAEV,AAAAQ,AAAA,AAAA,AAAoDV,AAAEC,AAAMU,AAAOT;AAAnE,AACE,AAAMU,AAAM,AAAA,AAAQV;AACdW,AAAU,AAAA,AAAYD;AACtBE,AAAU,AAACC,AAAWb,AAAKS;AAFjC,AAGE,AAAMO,AAAO,AAACC,AAAeP,AAAME;AAC7BF,AAAM,AAACQ,AAAUR,AAAME,AAAUI;AADvC,AAEE,AAAA,AAAA,AAACG,AAAMnB,AAAaU","names":["app3.interface.player/target","_","model","self","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","app3.tool/checkProperty","players","enemies","cljs.core/first","js/Error","app3.interface.player/updateBrain","target","brain","lastState","currState","app3.qlearning/mapState","isStateChange","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","action","app3.qlearning/selectAction","app3.qlearning/updateQ","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","offsetTime","js/Date"],"sourcesContent":["(ns app3.playerImpl\n  (:require-macros [app3.macros :as m])\n  (:require [app3.interface.player]\n            [app3.qlearning :as q]))\n\n\n(defmethod app3.interface.player/target :default [_ model self]\n  (m/lete [players [:player]\n           enemies [:enemy]]\n          (cond\n            (:player self) (first enemies)\n            (:enemy self) (first players)\n            true (js/Error. \"must have :player or :enemy\"))))\n\n\n(defmethod app3.interface.player/updateBrain :default [_ model target self]\n  (let [brain (:brain self)\n        lastState (:lastState brain)\n        currState (q/mapState self target)\n        isStateChange (not (= lastState currState))]\n    (if isStateChange\n      (let [action (q/selectAction brain currState)\n            brain (q/updateQ brain currState action)]\n        (merge self {:brain brain}))\n      (let [offsetTime (- (-> (js/Date.) .getTime)\n                          (:lastTime brain))]\n        (if (> offsetTime 3000)\n          (let [action (q/selectAction brain currState)\n                brain (q/updateQ brain currState action)]\n            (merge self {:brain brain}))\n          self)))))\n\n(defmethod app3.interface.player/updateBrain :fast [_ model target self]\n  (let [brain (:brain self)\n        lastState (:lastState brain)\n        currState (q/mapState self target)]\n    (let [action (q/selectAction brain currState)\n          brain (q/updateQ brain currState action)]\n      (merge self {:brain brain}))))"]}