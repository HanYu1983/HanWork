{"version":3,"sources":["app2/brain.cljs"],"mappings":"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","names":["app2.brain/brain","app2.brain/clearState","self","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","app2.brain/updateR","f","cljs.core.update.cljs$core$IFn$_invoke$arity$3","p__37480","map__37481","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","app2.brain/updateQ","lastState","lastAction","q","state","action","actions","and__4120__auto__","cljs.core.update_in.cljs$core$IFn$_invoke$arity$3","oldQ","learningRate","discountFactor","reward","maxV","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cljs.core/vector","cljs.core/get-in","cljs.core/max","newQ","nextQ","js/Date","app2.brain/actionR","app2.brain/actionQ","scores","cljs.core.replace.cljs$core$IFn$_invoke$arity$2","p1__37504#","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","app2.brain/log","a","cljs.core.print.cljs$core$IFn$_invoke$arity$variadic","app2.brain/selectAction","p1__37542#","scoresAddMin","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","cljs.core/inc","cljs.core/+","cljs.core/min","total","scoreNormalize","o","selectIdx","cljs.core/rand-int","cljs.core.map.cljs$core$IFn$_invoke$arity$3","cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic","p__37544","vec__37545","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","score","cljs.core.repeat.cljs$core$IFn$_invoke$arity$2","cljs.core.drop.cljs$core$IFn$_invoke$arity$2","cljs.core/first","app2.brain/bestAction","p1__37549#","best","p1__37551#","p2__37550#","cljs.core.sort.cljs$core$IFn$_invoke$arity$2","cljs.core/compare","cljs.core/last","cljs.core/ffirst"],"sourcesContent":["(ns app2.brain)\r\n\r\n(def brain {:q nil :r 0 :lastState nil :lastAction nil})\r\n\r\n(defn clearState [self]\r\n  (merge self {:lastState nil :lastAction nil}))\r\n\r\n(defn updateR [self f]\r\n  (update self :r f))\r\n\r\n(defn updateQ [{:keys [lastState lastAction q] :as self} state action actions]\r\n  (if (and lastState lastAction)\r\n    (->\r\n     (update-in self [:q lastState lastAction]\r\n                (fn [oldQ]\r\n                  (let [learningRate 0.5\r\n                        discountFactor 0.9\r\n                        reward (get self :r)\r\n                        maxV (->> actions\r\n                                  (map (partial vector state))\r\n                                  (map (partial get-in q))\r\n                                  (apply max))\r\n                        newQ (+ reward (* discountFactor maxV))\r\n                        nextQ (+ (* (- 1 learningRate) oldQ) (* learningRate newQ))]\r\n                    nextQ)))\r\n     (merge {:lastState state\r\n             :lastAction action\r\n             :lastTime (-> (js/Date.) .getTime)\r\n             :r 0}))\r\n    (merge self {:lastState state :lastAction action})))\r\n\r\n(defn actionR [self]\r\n  (:r self))\r\n\r\n(defn actionQ [self state actions]\r\n  (let [scores (replace {nil 0}\r\n                        (map #(get-in self [:q state %])\r\n                             actions))]\r\n    scores))\r\n\r\n(defn log [a]\r\n  (print a)\r\n  a)\r\n\r\n(defn selectAction [self state actions]\r\n  (let [scores (replace {nil 0} (map #(get-in self [:q state %]) actions))\r\n        scoresAddMin (map (comp inc (partial + (- (apply min scores)))) scores)\r\n        total (apply + scoresAddMin)\r\n        scoreNormalize (map (fn [o]\r\n                              (-> o\r\n                                  (* 100)\r\n                                  (/ total)\r\n                                  int))\r\n                            scoresAddMin)\r\n        selectIdx (rand-int (apply + scoreNormalize))\r\n        action (->> (map vector actions scoreNormalize)\r\n                    (mapcat (fn [[action score]]\r\n                              (repeat score action)))\r\n                    (drop selectIdx)\r\n                    first)]\r\n    action))\r\n\r\n(defn bestAction [self state actions]\r\n  (let [scores (replace {nil 0} (map #(get-in self [:q state %]) actions))\r\n        best (->> (map vector actions scores)\r\n                  (sort #(compare (last %2) (last %1)))\r\n                  ffirst)]\r\n    best))"]}